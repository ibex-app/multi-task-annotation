<!DOCTYPE html>
<html>

<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        @import url("https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap");

        body {
            background: #2b2b2b;
            color: #e7e7e7;
            font-family: "Roboto", sans-serif;
        }

        span.word {
            display: inline-flex;
            flex-direction: column;
            /* padding: 2px 4px; */
            position: relative;
            /* margin: 10px 0; */
            cursor: pointer;
        }

        span.word span {
            width: 100%;
            display: block;
            /* min-height: 10px; */
            height: 0px;
            margin-bottom: 20px;
            /* margin-top: 10px; */
            border: 2.5px solid transparent;
            /* text-overflow: ellipsis;
            overflow: hidden;
            width: 160px;
            height: 1.2em;
            white-space: nowrap; */
        }

        span.word span:first-child {
            height: auto;
            margin-bottom: 5px;
            border: none;
        }

        .sent {
            margin: 50px;
        }

        span.word i {
            position: absolute;
            font-size: 11px;
            white-space: nowrap;
            top: 5px;
            font-weight: bold;
        }

        span.word span.last {
            width: calc(100% - 18px);
            border-top-right-radius: 5px;
            border-bottom-right-radius: 5px;
        }

        span.word span.first {
            width: calc(100% - 17px);
            display: inline-block;
            align-self: end;
            position: relative;
            border-top-left-radius: 5px;
            border-bottom-left-radius: 5px;
        }

        span.word span.first::before {
            position: absolute;
            content: "";
            border-radius: 100%;
            width: 8px;
            height: 8px;
            background: inherit;
            top: -4px;
            left: -13px;
        }

        ::-moz-selection {
            /* Code for Firefox */
            color: inherit;
            background: inherit;
        }

        ::selection {
            color: inherit;
            background: inherit;
        }


        .plans .plan input[type="radio"] {
            position: absolute;
            opacity: 0;
        }

        .plans .plan {
            cursor: pointer;
            width: 48.5%;
        }

        .plans .plan .plan-content {
            display: -webkit-box;
            display: -ms-flexbox;
            display: flex;
            padding: 30px;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
            border: 2px solid #e1e2e7;
            border-radius: 10px;
            -webkit-transition: -webkit-box-shadow 0.4s;
            transition: -webkit-box-shadow 0.4s;
            -o-transition: box-shadow 0.4s;
            transition: box-shadow 0.4s;
            transition: box-shadow 0.4s, -webkit-box-shadow 0.4s;
            position: relative;
        }

        .plans .plan .plan-content img {
            margin-right: 30px;
            height: 72px;
        }

        .plans .plan .plan-details span {
            margin-bottom: 10px;
            display: block;
            font-size: 20px;
            line-height: 24px;
            color: #252f42;
        }

        .container .title {
            font-size: 16px;
            font-weight: 500;
            -ms-flex-preferred-size: 100%;
            flex-basis: 100%;
            color: #252f42;
            margin-bottom: 20px;
        }

        .plans .plan .plan-details p {
            color: #646a79;
            font-size: 14px;
            line-height: 18px;
        }

        .plans .plan .plan-content:hover {
            -webkit-box-shadow: 0px 3px 5px 0px #e8e8e8;
            box-shadow: 0px 3px 5px 0px #e8e8e8;
        }

        .plans .plan input[type="radio"]:checked+.plan-content:after {
            content: "";
            position: absolute;
            height: 8px;
            width: 8px;
            background: #216fe0;
            right: 20px;
            top: 20px;
            border-radius: 100%;
            border: 3px solid #fff;
            -webkit-box-shadow: 0px 0px 0px 2px #0066ff;
            box-shadow: 0px 0px 0px 2px #0066ff;
        }

        .plans .plan input[type="radio"]:checked+.plan-content {
            border: 2px solid #216ee0;
            background: #eaf1fe;
            -webkit-transition: ease-in 0.3s;
            -o-transition: ease-in 0.3s;
            transition: ease-in 0.3s;
        }

        * {
            touch-action: none;
        }

        span.word span.hide {
            height: 0;
            margin: 0;
            border: none;
        }

        span.word.selected span:first-child {
            background: rgba(255, 255, 255, 0.2) none repeat scroll 0% 0%;
            border: none;
        }

        button {
            width: 100%;
            height: 30px;
        }
    </style>
</head>

<body>

    <div class="sent">
        When you need to annotate a word or a phrase, you'll use Tags to say what the annotation is. Examples of tags
        are Person, Location, Object, Noun etc. You can use any tags in any language.
    </div>
    <div>
        <button id="save">save</button>
        <div data-step=1>
            Conflict category<br>
            <input type="radio" />DPI<br>
            <input type="radio" />Border<br>
            <input type="radio" />Refugies<br>
            <input type="radio" />Prisoners<br>
        </div>
        <div data-step=1>
            Contains :<br>
            <input type="checkbox" /> Conflict related topic<br>
            <input type="checkbox" /> Extremizm<br>
            <input type="checkbox" /> Gender based hate speech<br>
            <input type="checkbox" /> Terorism<br>
            <input type="checkbox" /> Hate Speech<br>
        </div>
        <div data-step=1>
            Is :<br>
            <input type="checkbox" /> Anti Gov<br>
            <input type="checkbox" /> Pro Gov<br>
            <input type="checkbox" /> Anti Opo<br>
            <input type="checkbox" /> Pro Opo<br>
            <input type="checkbox" /> Anti West<br>
            <input type="checkbox" /> Pro West<br>
            <input type="checkbox" /> Anti Russ<br>
            <input type="checkbox" /> Pro Russ<br>

        </div>

    </div>

</body>
<script>

    var colIndex = 1
    var cols = ["white", "blue", "black", "yellow", "gray", "green", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick"]


    var drowBorders = () => {

        return

        words.forEach(wordInfo => {
            wordInfo.dom.style.paddingLeft = ''
            wordInfo.dom.style.paddingRight = ''
        })
        words.forEach((wordInfo, index) => {
            if (wordInfo.borders.length == 0) return
            wordInfo.borders = wordInfo.borders.sort((a, b) => a.layer > b.layer)
            let topBorder = wordInfo.borders[wordInfo.borders.length - 1]
            if (topBorder.first && words[index - 1]) {
                words[index - 1].dom.style.paddingRight = (3 + topBorder.layer * 3.3) + 'px'
            }
            if (topBorder.last && words[index + 1]) {
                words[index + 1].dom.style.paddingLeft = (3 + topBorder.layer * 3.3) + 'px'
            }
        })
        words.forEach(wordInfo => {
            if (wordInfo.borders.length == 0) return
            wordInfo.dom.style.zIndex = 100 + wordInfo.borders.length
            wordInfo.borders = wordInfo.borders.sort((a, b) => a.layer > b.layer)
            let lastLayer = wordInfo.borders[wordInfo.borders.length - 1].layer
            let existingLayers = wordInfo.borders.map(b => b.layer)
            let left = 4
            for (let i = 1; i <= lastLayer; i++) {
                if (existingLayers.indexOf(i) == -1) {
                    left += 3
                    wordInfo.borders.push({ colorIndex: 0, first: true, last: true, layer: i })
                }
            }
            left = left > 8 ? 8 : left
            wordInfo.borders = wordInfo.borders.sort((a, b) => a.layer > b.layer)
            wordInfo.dom.style.boxShadow = wordInfo.borders.map(getBorderString).join(' , ')
            wordInfo.dom.style.paddingLeft = left + 'px'
            wordInfo.dom.style.paddingRight = left + 'px'
        })
    }

    var highlight = () => {
        words.forEach(wordInfo => {
            if (wordInfo.selecting) {

                wordInfo.dom.classList.add('selected')
            } else {
                wordInfo.dom.classList.remove('selected')
            }
        })
    }

    var onmousedown_ = (e) => {
        if (!cntrlIsPressed) words.forEach(wordInfo => wordInfo.selecting = false)
        startSelection = true
        let targetIndex = parseInt(e.currentTarget.getAttribute('index'))
        let theWord = words.find(wordInfo => wordInfo.index == targetIndex)
        theWord.selecting = true
        highlight()
        e.preventDefault()
    }
    var ontouchmove_ = (e) => {
        var evt = (typeof e.originalEvent === 'undefined') ? e : e.originalEvent;
        var touch = evt.touches[0] || evt.changedTouches[0];
        el = document.elementFromPoint(touch.pageX, touch.pageY)

        currentTarget = el.getAttribute("index") ? el : el.parentElement
        onmouseenter_(e, currentTarget)
        // console.log(currentTarget)
    }

    var onmouseenter_ = (e, currentTarget) => {
        if (!startSelection) return
        currentTarget = currentTarget || e.currentTarget

        let targetIndex = parseInt(currentTarget.getAttribute('index'))
        let theWord = words.find(wordInfo => wordInfo.index == targetIndex)
        let nextWord = words.find(wordInfo => wordInfo.index == targetIndex + 1)
        let prevtWord = words.find(wordInfo => wordInfo.index == targetIndex - 1)
        // console.log(prevtWord.index, theWord.index, nextWord.index)

        if ((nextWord && nextWord.selecting) || (prevtWord && prevtWord.selecting)) theWord.selecting = true
        highlight()
        e.preventDefault()
    }

    var onmouseup_ = (e) => {
        startSelection = false
        e.preventDefault()
    }

    cont = document.querySelector('div.sent')
    // document.onmouseup = onmouseup_
    // document.ontouchcancel = onmouseup_
    // document.ontouchend = onmouseup_

    text = cont.innerText
    cont.innerHTML = ''
    words = text.split(' ').map(t => ({ text: t }))
    startSelection = false

    var cntrlIsPressed = false;

    document.body.addEventListener('keydown', (e) => {
        if (17 == e.which) cntrlIsPressed = true
    });

    document.body.addEventListener('keyup', (e) => {
        cntrlIsPressed = false;
    });



    words.forEach((wordInfo, wordIndex) => {
        span = document.createElement('span')
        span.setAttribute('index', wordIndex)
        span.setAttribute('draggable', false)

        span.className = 'word'
        span.innerHTML = '<span>' + wordInfo.text + '&nbsp;</span>'
        cont.appendChild(span)

        span.onmousedown = onmousedown_
        span.onmouseenter = onmouseenter

        // span.onmouseenter = onmouseenter_
        // span.ontouchenter = onmouseenter_

        // span.addEventListener("pointerdown", onmousedown_)
        span.addEventListener("pointerenter", onmouseenter_)


        span.addEventListener("touchstart", onmousedown_)
        span.addEventListener("touchmove", ontouchmove_)
        // span.addEventListener("touchenter", console.log)
        // document.elementFromPoint(touch.x, touch.y);

        // on touchmove event.
        // div.addEventListener("pointerleave",(e)=>{
        //     console.log("leave")
        // })
        span.onmouseup = onmouseup_
        span.ontouchcancel = onmouseup_
        span.ontouchend = onmouseup_

        wordInfo.dom = span
        wordInfo.index = wordIndex
        wordInfo.borders = []
        wordInfo.selecting = false

    })


    drowBorders()

    var orderLayers = () => {

    }

    var tags = []

    var tagId = tags.length
    var max_layers

    var orderTags = () => {
        let allTaggedWords = [].concat.apply([], tags.map(tag => tag.words))
        countOfWords = allTaggedWords.reduce((acc, e) => acc.set(e, (acc.get(e) || 0) + 1), new Map());

        max_layers = Array.from(countOfWords, ([name, value]) => ({ name, value })).sort((a, b) => b.value - a.value)[0].value
        words.forEach(wordInfo => {
            wordInfo.occupiedLayers = []
            wordInfo.dom.innerHTML = '<span>' + wordInfo.text + '&nbsp;</span>'
            for (let layer_index = 0; layer_index < max_layers; layer_index++) {
                let span = document.createElement('span')
                wordInfo.dom.appendChild(span)
            }
        })

        tags.forEach(tag => {
            let tagWords = tag.words.map(wordIndex => words.find(word => word.index == wordIndex))
            let avaliableLayer
            let isAvaliable
            for (avaliableLayer = 1; avaliableLayer <= max_layers; avaliableLayer++) {
                isAvaliable = tagWords.reduce((isAvaliable, wordInfo) => {
                    if (!isAvaliable) return isAvaliable
                    return wordInfo.occupiedLayers.indexOf(avaliableLayer) === -1
                }, !0)
                if (isAvaliable) break
            }

            tagWords.forEach((wordInfo, wordInd) => {
                if (!isAvaliable) {
                    let span = document.createElement('span')
                    wordInfo.dom.appendChild(span)
                    avaliableLayer++
                }
                // console.log(wordInfo, avaliableLayer)

                span = wordInfo.dom.querySelector('span:nth-child(' + (avaliableLayer + 1) + ')')
                span.style.border = '2.5px solid ' + cols[tag.colorIndex]
                span.style.background = cols[tag.colorIndex]
                if (wordInd == 0) {
                    span.classList.add('first')
                    span.innerHTML = '<i style="color:' + cols[tag.colorIndex] + '">Entity # 12</i>'
                }
                if (wordInd == tagWords.length - 1) span.classList.add('last')
                wordInfo.occupiedLayers.push(avaliableLayer)
            })
        })

        return
    }
    var lines
    var hideemptylines = () => {
        cont = document.querySelector('div.sent')
        widdth = cont.offsetWidth
        lines = [[]]
        offset = 0
        words.forEach(wordInfo => {
            if (offset + wordInfo.dom.offsetWidth <= cont.offsetWidth) {
                lines[lines.length - 1].push(wordInfo)
                offset += wordInfo.dom.offsetWidth
            } else {
                lines.push([wordInfo])
                offset = wordInfo.dom.offsetWidth
            }
        })
        lines.forEach(line => {
            for (let layer_index = max_layers; layer_index > 0; layer_index--) {
                let spans_in_a_line = line.map(wordInfo => wordInfo.dom.querySelectorAll('span')[layer_index])
                let no_of_underlines = spans_in_a_line.map(a => !a.className && !a.getAttribute('style')).every(Boolean)
                if (no_of_underlines) {
                    spans_in_a_line.forEach(sp => sp.className = 'hide')
                } else {
                    break
                }
            }

        })

    }

    var save = () => {
        selectedIndexes = words.filter(wordInfo => wordInfo.selecting).map(wordInfo => wordInfo.index)
        if (selectedIndexes.length !== 0) tags.push({ id: tagId, colorIndex: colIndex, words: selectedIndexes })

        tags.forEach(tag => tag.drown = false)
        words.forEach(wordInfo => {
            wordInfo.selecting = false
            wordInfo.borders = []
        })
        highlight()
        orderTags()
        drowBorders()
        hideemptylines()
        colIndex++
        tagId++
    }

    document.getElementById('save').addEventListener("click", save)
    document.onkeypress = (e => {
        if (e.keyCode == 13) {
            save()
        }

    })


</script>

</html>

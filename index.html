<!DOCTYPE html>
<html>

<head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
    <meta content="utf-8" http-equiv="encoding">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1"> -->
    <meta name="viewport" content="height=device-height, 
                      width=device-width, initial-scale=1.0, 
                      minimum-scale=1.0, maximum-scale=1.0, 
                      user-scalable=no, target-densitydpi=device-dpi">
    <style>
        @import url("https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap");

        body {
            background: #eeeae7;
            color: #232324;
            font-family: sans-serif;
            margin: 0;
            /* display: flex; */
            /* flex-wrap: wrap; */
            /* flex-direction: column; */
            height: 100%;
            position: fixed;
            width: 100%;
            left: 0;
            top: 0;
        }
        .header {
            background: #d0c6bf;
            width: 100%;
        }
        .bottom-line{
            position: fixed;
            bottom:0;
            left: 0;
            /* height: 20vh; */
            width: 100%;
            /* box-shadow: 0 0 2px 3px #51505040; */
            background: #d0c6bf;
            z-index: 10;
        }
        .sent {
            padding: 10px 2vw;
            width: 100%;
            /* position: fixed; */
            overflow-y: auto;
            /* flex-grow: 5; */
            padding-bottom: 10vh;
            height: calc(100% - 17vh);
            line-height: 1.7em;
        }

        *{
            box-sizing: border-box;
        }
        span.word {
            display: inline-flex;
            flex-direction: column;
            /* padding: 2px 4px; */
            position: relative;
            /* margin: 10px 0; */
            cursor: pointer;
            font-size: 1.3em;
        }

        span.word span {
            width: 100%;
            display: block;
            /* min-height: 10px; */
            height: 0px;
            margin-bottom: 9px;
            /* margin-top: 10px; */
            border: 2.5px solid transparent;
            position: relative;
            /* text-overflow: ellipsis;
            overflow: hidden;
            width: 160px;
            height: 1.2em;
            white-space: nowrap; */
            /* padding-left: 2.5px;
            padding-right: 2.5px; */
            /* margin-left: 2.5px; */
            
        }

        span.word span:first-child {
            height: auto;
            margin-bottom: 5px;
            border: none;
            /* padding-left: 4px; */
            padding-bottom: 1px;
            padding-left: 3.5px;
            padding-right: 3.5px;
            
        }
        

        span.word i {
            position: absolute;
            font-size: 11px;
            white-space: nowrap;
            top: -17px;
            font-weight: bold;
            color: #545454;
            padding-left: 3px;
            text-shadow: 0px 1px 3px white, 0px 2px 2px white;
        }

        span.word span.last {
            width: 100%;
            /* border-top-right-radius: 5px;
            border-bottom-right-radius: 5px; */
        }

        span.word span.first {
            width: 100%;
            /* display: inline-block; */
            /* align-self: end; */
            
            /* border-top-left-radius: 5px;
            border-bottom-left-radius: 5px; */
            z-index: 5;
        }

        span.word span.first::before {
            position: absolute;
            content: "";
            border-top-right-radius: 100%;
            width: 0px;
            height: 5px;
            background: inherit;
            bottom: 0;
            left: -2px;
            border: 2.5px solid;
            border-color: inherit;

        }
        span.word span.last{
            position: relative;
        }
        span.word span.last::after {
            position: absolute;
            content: "";
            border-top-left-radius: 100%;
            width: 0px;
            height: 5px;
            background: inherit;
            bottom: 0;
            right: -2px;
            border: 2.5px solid;
            border-color: inherit;

        }
        ::-moz-selection {
            /* Code for Firefox */
            color: inherit;
            background: inherit;
        }

        ::selection {
            color: inherit;
            background: inherit;
        }


        .plans .plan input[type="radio"] {
            position: absolute;
            opacity: 0;
        }

        .plans .plan {
            cursor: pointer;
            width: 48.5%;
        }

        .plans .plan .plan-content {
            display: -webkit-box;
            display: -ms-flexbox;
            display: flex;
            padding: 30px;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
            border: 2px solid #e1e2e7;
            border-radius: 10px;
            -webkit-transition: -webkit-box-shadow 0.4s;
            transition: -webkit-box-shadow 0.4s;
            -o-transition: box-shadow 0.4s;
            transition: box-shadow 0.4s;
            transition: box-shadow 0.4s, -webkit-box-shadow 0.4s;
            position: relative;
        }

        .plans .plan .plan-content img {
            margin-right: 30px;
            height: 72px;
        }

        .plans .plan .plan-details span {
            margin-bottom: 10px;
            display: block;
            font-size: 20px;
            line-height: 24px;
            color: #252f42;
        }

        .container .title {
            font-size: 16px;
            font-weight: 500;
            -ms-flex-preferred-size: 100%;
            flex-basis: 100%;
            color: #252f42;
            margin-bottom: 20px;
        }

        .plans .plan .plan-details p {
            color: #646a79;
            font-size: 14px;
            line-height: 18px;
        }

        .plans .plan .plan-content:hover {
            -webkit-box-shadow: 0px 3px 5px 0px #e8e8e8;
            box-shadow: 0px 3px 5px 0px #e8e8e8;
        }

        .plans .plan input[type="radio"]:checked+.plan-content:after {
            content: "";
            position: absolute;
            height: 8px;
            width: 8px;
            background: #216fe0;
            right: 20px;
            top: 20px;
            border-radius: 100%;
            border: 3px solid #fff;
            -webkit-box-shadow: 0px 0px 0px 2px #0066ff;
            box-shadow: 0px 0px 0px 2px #0066ff;
        }

        .plans .plan input[type="radio"]:checked+.plan-content {
            border: 2px solid #216ee0;
            background: #eaf1fe;
            -webkit-transition: ease-in 0.3s;
            -o-transition: ease-in 0.3s;
            transition: ease-in 0.3s;
        }

        * {
            touch-action: none;
        }

        span.word span.hide {
            height: 0;
            margin: 0;
            border: none;
        }

        span.word.selected span:nth-child(1) {
            background: rgba(0,0,0, 0.2) none repeat scroll 0% 0%;
            border: none;
        }

        span.word.selected:first-child > span:first-child {
            overflow: hidden;
            border-bottom-left-radius: 5px;
            border-top-left-radius: 5px;
        }

        span.selected.word:last-child > span:first-child {
            overflow: hidden;
            border-bottom-right-radius: 5px;
            border-top-right-radius: 5px;
        }

        button {
            width: 100%;
            height: 30px;
        }
        

        
        .bottom-line > div{
            /* position: absolute; */
            margin-left: 50px;
            left: 50px;
            width: calc(100% - 100px);
            /* height: 20vh; */
            display: none;
            padding: 3px 0px;
            top: 0;
        }
        .bottom-line > div.show{
            display: block;
        }
        
        .bottom-line > span.prev{
            background: #8d639a;
            left: 8px;
            position: absolute;
            bottom: 4.5px;

        }
        .bottom-line > span.next{
            background: #8d639a;
            margin-right: 12px;
            left: auto;
            right: 0px;
            bottom: 4.5px;

            position: absolute;
        }
        .bottom-line > div > span, .bottom-line > span, .header > span.save{
            text-align: center;
            padding: 5px 9px;
            cursor: pointer;
            margin: 3px 3px;
            display: inline-block;
            background: #828687; 
            /* #bf501f; */
            color: whitesmoke;
            border-radius: 5px;
        }
       
        .header > span {
            padding: 8px;
            cursor: pointer;
            margin: 3px 3px;
            display: inline-block;
            color: #4e31314d;
        }
        

        .header > span.save {
            display: block;
            right: 8px;
            position: absolute;
            top: 3px;
            background: #7bc597;
        }
        * {
            -webkit-touch-callout: none; /* iOS Safari */
                -webkit-user-select: none; /* Safari */
                -khtml-user-select: none; /* Konqueror HTML */
                -moz-user-select: none; /* Firefox */
                    -ms-user-select: none; /* Internet Explorer/Edge */
                        user-select: none; /* Non-prefixed version, currently
                                            supported by Chrome and Opera */
            }
    </style>
</head>

<body>
    <div class="header">
        <span>Q-723</span> <span>35 / 1753 / 4675</span> <span class="save" >save</a>
    </div>
    <div class="sent">
        
    </div>
    
    <div class="bottom-line">
        <span onclick="prev()" class="prev">«</span>
        <span onclick="next()" class="next">»</span>
    
    </div>

</body>
<script>

    var colIndex = 1
    var cols = ["black", "#bf501f", "#f59c34", "#89a7c6", "#7bc597", "#8d639a", "#8d639a", "#e4a774", "#828687", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick"]


    var drowBorders = () => {

        return

        words.forEach(wordInfo => {
            wordInfo.dom.style.paddingLeft = ''
            wordInfo.dom.style.paddingRight = ''
        })
        words.forEach((wordInfo, index) => {
            if (wordInfo.borders.length == 0) return
            wordInfo.borders = wordInfo.borders.sort((a, b) => a.layer > b.layer)
            let topBorder = wordInfo.borders[wordInfo.borders.length - 1]
            if (topBorder.first && words[index - 1]) {
                words[index - 1].dom.style.paddingRight = (3 + topBorder.layer * 3.3) + 'px'
            }
            if (topBorder.last && words[index + 1]) {
                words[index + 1].dom.style.paddingLeft = (3 + topBorder.layer * 3.3) + 'px'
            }
        })
        words.forEach(wordInfo => {
            if (wordInfo.borders.length == 0) return
            wordInfo.dom.style.zIndex = 100 + wordInfo.borders.length
            wordInfo.borders = wordInfo.borders.sort((a, b) => a.layer > b.layer)
            let lastLayer = wordInfo.borders[wordInfo.borders.length - 1].layer
            let existingLayers = wordInfo.borders.map(b => b.layer)
            let left = 4
            for (let i = 1; i <= lastLayer; i++) {
                if (existingLayers.indexOf(i) == -1) {
                    left += 3
                    wordInfo.borders.push({ colorIndex: 0, first: true, last: true, layer: i })
                }
            }
            left = left > 8 ? 8 : left
            wordInfo.borders = wordInfo.borders.sort((a, b) => a.layer > b.layer)
            wordInfo.dom.style.boxShadow = wordInfo.borders.map(getBorderString).join(' , ')
            wordInfo.dom.style.paddingLeft = left + 'px'
            wordInfo.dom.style.paddingRight = left + 'px'
        })
    }

    var partOfSpeechMode = false
    var startIndex
    var endIndex

    var highlight = () => {
        let startIndex_ = startIndex < endIndex ? startIndex : endIndex 
        let endIndex_ = startIndex > endIndex ? startIndex : endIndex 

        let selected = words.filter(wordInfo => wordInfo.index >= startIndex_ && wordInfo.index <= endIndex_)
        

        words.forEach(wordInfo => {
            wordInfo.selecting = false
            wordInfo.dom.classList.remove('selected')
            wordInfo.dom.firstChild.setAttribute('style', '')
        })

        selected.forEach((wordInfo, ind) => {
            wordInfo.selecting = true
            wordInfo.dom.classList.add('selected')
            
            if(ind == 0) {
                wordInfo.dom.firstChild.setAttribute('style', 'border-bottom-left-radius: 5px; border-top-left-radius: 5px;')
            }
            if(ind == selected.length - 1) { 
                wordInfo.dom.firstChild.setAttribute('style', wordInfo.dom.firstChild.getAttribute('style') + ' border-bottom-right-radius: 5px; border-top-right-radius: 5px;')
            }
        })
        
        partOfSpeechMode = selected.length > 0
    }
    

    var onmousedown_ = (e) => {
        if (e.touches.length === 2) return
        // if (!cntrlIsPressed) 
        // words.forEach(wordInfo => wordInfo.selecting = false)
        startSelection = true
        startIndex = parseInt(e.currentTarget.getAttribute('index'))
        endIndex = startIndex
        // let targetIndex = parseInt(e.currentTarget.getAttribute('index'))
        // let theWord = words.find(wordInfo => wordInfo.index == targetIndex)
        // startToken = theWord
        // theWord.selecting = true
        highlight()
        // e.preventDefault()
    }
    var ontouchmove_ = (e) => {
        if (e.touches.length === 2) return
        var evt = (typeof e.originalEvent === 'undefined') ? e : e.originalEvent;
        var touch = evt.touches[0] || evt.changedTouches[0];
        el = document.elementFromPoint(touch.pageX, touch.pageY)

        currentTarget = el.getAttribute("index") ? el : el.parentElement
        onmouseenter_(e, currentTarget)
    }

    var onmouseenter_ = (e, currentTarget) => {
        if (e.touches.length === 2) return
        if (!startSelection) return
        currentTarget = currentTarget || e.currentTarget
        endIndex = parseInt(currentTarget.getAttribute('index'))
        // let targetIndex = parseInt(currentTarget.getAttribute('index'))
        // let theWord = words.find(wordInfo => wordInfo.index == targetIndex)
        // let nextWord = words.find(wordInfo => wordInfo.index == targetIndex + 1)
        // let prevtWord = words.find(wordInfo => wordInfo.index == targetIndex - 1)

        // if ((nextWord && nextWord.selecting) || (prevtWord && prevtWord.selecting)) theWord.selecting = true
        highlight()
        // e.preventDefault()
    }

    var onmouseup_ = (e) => {
        startSelection = false
        // e.preventDefault()
    }

    var cont = document.querySelector('div.sent')
    
    const dehightlight = (e) => {
        
        if(e.target.className == 'sent'){
            startIndex = -1
            endIndex = -1

            highlight()
        }
    }

    cont.ontouchend = dehightlight
    cont.onmouseup = dehightlight

    var cntrlIsPressed = false;

    document.body.addEventListener('keydown', (e) => { if (17 == e.which) cntrlIsPressed = true });

    document.body.addEventListener('keyup', (e) => cntrlIsPressed = false );

    var startSelection = false
    var tags = []
    var tagId = tags.length
    var max_layers

    cont.ontouchstart =  (event) => {
        if (event.touches.length === 2) {
            event.preventDefault()
            lastTouchY = event.touches[0].clientY;
        }
    }

    cont.ontouchmove = (event) => {
        if (event.touches.length === 2){
            event.preventDefault()

            const delta = lastTouchY - event.touches[0].clientY;
            lastTouchY = event.touches[0].clientY;
    
            cont.scrollTop += delta;
        }
    }

    const display_sent = (text) => {

    
        startSelection = false
        cont.innerHTML = ''
        words = text.split(' ').map(a => a.trim()).map(t => ({ text: t }))
        

        words.forEach((wordInfo, wordIndex) => {
            span = document.createElement('span')
            span.setAttribute('index', wordIndex)
            span.setAttribute('draggable', false)

            span.className = 'word'
            span.innerHTML = '<span>' + wordInfo.text + '</span>'
            cont.appendChild(span)

            span.onmousedown = onmousedown_
            span.onmouseenter = onmouseenter

            span.addEventListener("pointerenter", onmouseenter_)


            span.addEventListener("touchstart", onmousedown_)
            span.addEventListener("touchmove", ontouchmove_)
        
            span.onmouseup = onmouseup_
            span.ontouchcancel = onmouseup_
            span.ontouchend = onmouseup_

            wordInfo.dom = span
            wordInfo.index = wordIndex
            wordInfo.borders = []
            wordInfo.selecting = false

        })


        drowBorders()
        tags = []
        tagId = tags.length
    }

    var orderTags = () => {
        let allTaggedWords = [].concat.apply([], tags.map(tag => tag.words))
        
        countOfWords = allTaggedWords.reduce((acc, e) => acc.set(e, (acc.get(e) || 0) + 1), new Map());
        
        max_layers = Array.from(countOfWords, ([name, value]) => ({ name, value })).sort((a, b) => b.value - a.value)[0].value
        words.forEach(wordInfo => {
            wordInfo.occupiedLayers = []
            wordInfo.dom.innerHTML = '<span>' + wordInfo.text + '</span>'
            for (let layer_index = 0; layer_index < max_layers; layer_index++) {
                let span = document.createElement('span')
                wordInfo.dom.appendChild(span)
            }
        })

        tags.forEach(tag => {
            let tagWords = tag.words.map(wordIndex => words.find(word => word.index == wordIndex))
            let avaliableLayer
            let isAvaliable
            for (avaliableLayer = 1; avaliableLayer <= max_layers; avaliableLayer++) {
                isAvaliable = tagWords.reduce((isAvaliable, wordInfo) => {
                    if (!isAvaliable) return isAvaliable
                    return wordInfo.occupiedLayers.indexOf(avaliableLayer) === -1
                }, !0)
                if (isAvaliable) break
            }

            tagWords.forEach((wordInfo, wordInd) => {
                if (!isAvaliable) {
                    let span = document.createElement('span')
                    wordInfo.dom.appendChild(span)
                    avaliableLayer++
                }

                span = wordInfo.dom.querySelector('span:nth-child(' + (avaliableLayer + 1) + ')')
                span.style.border = '2.5px solid ' + cols[tag.colorIndex]
                span.style.background = cols[tag.colorIndex]
                if (wordInd == 0) {
                    span.classList.add('first')
                    // span.innerHTML = '<i style="color:' + cols[tag.colorIndex] + '">Entity # 12</i>'
                    span.innerHTML = '<i style="">' + tag.label + '</i>'
                }
                if (wordInd == tagWords.length - 1) span.classList.add('last')
                wordInfo.occupiedLayers.push(avaliableLayer)
            })
        })

        return
    }
    
    var lines

    var hideemptylines = () => {
        cont = document.querySelector('div.sent')
        let contWidth 
        var style = window.getComputedStyle(cont, null);
        contWidth = style.getPropertyValue("width");

        // contWidth = cont.offsetWidth
        lines = [[]]
        offset = 0
        words.forEach(wordInfo => {
            if (offset + wordInfo.dom.offsetWidth <= contWidth - 200) {
                lines[lines.length - 1].push(wordInfo)
                offset += wordInfo.dom.offsetWidth
            } else {
                lines.push([wordInfo])
                offset = wordInfo.dom.offsetWidth
            }
        })
        lines.forEach(line => {
            for (let layer_index = max_layers; layer_index > 0; layer_index--) {
                let spans_in_a_line = line.map(wordInfo => wordInfo.dom.querySelectorAll('span')[layer_index])
                let no_of_underlines = spans_in_a_line.map(a => !a.className && !a.getAttribute('style')).every(Boolean)
                if (no_of_underlines) {
                    spans_in_a_line.forEach(sp => sp.className = 'hide')
                } else {
                    break
                }
            }

        })

    }

    var save = (label) => {
        selectedIndexes = words.filter(wordInfo => wordInfo.selecting).map(wordInfo => wordInfo.index)
        if (selectedIndexes.length !== 0) tags.push({ id: tagId, label: label, colorIndex: colIndex, words: selectedIndexes })

        tags.forEach(tag => tag.drown = false)
        words.forEach(wordInfo => {
            wordInfo.selecting = false
            wordInfo.borders = []
        })

        dehightlight({target:{className: 'sent'}})
        orderTags()
        drowBorders()
        hideemptylines()
        colIndex++
        tagId++
    }

    
    
    var sentences = [
        {id:1, text: "სამხრეთ აფრიკის პარლამენტში ხანძარი გაჩნდა. ცეცხლი შენობის სახურავიდან ამოდიოდა და კვამლი კილომეტრების მოშორებით ჩანდა. ინფორმაციას Reuters ავრცელებს. ინფრასტრუქტურის მინისტრმა პატრიცია დე ლილემ ჟურნალისტებს განუცხადა, რომ ხანძარი ლოკალიზებულია. მისი თქმით, დამწვარია ეროვნული ასამბლეის დარბაზი და ხანძარი მოედო სხვა ტერიტორიასაც. პირველადი ინფორმაციით, ხანძარი ერთ-ერთ ოფისში გაჩნდა და სპორტული დარბაზისკენ გავრცელდა. დე ლილის თქმით, ხანძრის შედეგად დაშავებულების შესახებ ინფორმაცია არ ვრცელდება. ხელისუფლების განცხადებით, მეხანძრეები სიტუაციას აკონტროლებენ. ხანძრის გამომწვევი მიზეზი ჯერჯერობით უცნობია. სამხრეთ აფრიკის პარლამენტში ხანძარი გაჩნდა. ცეცხლი შენობის სახურავიდან ამოდიოდა და კვამლი კილომეტრების მოშორებით ჩანდა. ინფორმაციას Reuters ავრცელებს. ინფრასტრუქტურის მინისტრმა პატრიცია დე ლილემ ჟურნალისტებს განუცხადა, რომ ხანძარი ლოკალიზებულია. მისი თქმით, დამწვარია ეროვნული ასამბლეის დარბაზი და ხანძარი მოედო სხვა ტერიტორიასაც. პირველადი ინფორმაციით, ხანძარი ერთ-ერთ ოფისში გაჩნდა და სპორტული დარბაზისკენ გავრცელდა. დე ლილის თქმით, ხანძრის შედეგად დაშავებულების შესახებ ინფორმაცია არ ვრცელდება. ხელისუფლების განცხადებით, მეხანძრეები სიტუაციას აკონტროლებენ. ხანძრის გამომწვევი მიზეზი ჯერჯერობით უცნობია."},
        {id:1, text: "When you need to annotate a word or a phrase, you'll use Tags to say what the annotation is. Examples of tags are Person, Location, Object, Noun etc. You can use any tags in any language. When you need to annotate a word or a phrase, you'll use Tags to say what the annotation is. Examples of tags are Person, Location, Object, Noun etc. You can use any tags in any language."},
        {id:1, text: "ინტენსიური თოვის და დაბალი ტემპერატურის გამო, შიდასახელმწიფოებრივი მნიშვნელობის გომი-საჩხერე-ჭიათურა-ზესტაფონის საავტომობილო გზის კმ18-კმ40 მონაკვეთზე, აკრძალულია მისაბმელიანი და ნახევრადმისაბმელიანი ავტოტრანსპორტის მოძრაობა, ხოლო დანარჩენი სახის ავტოტრანსპორტის მოძრაობა თავისუფალია. საავტომობილო გზების დეპარტამენტის ინფორმაციით, გზის დანარჩენ მონაკვეთზე ავტოტრანსპორტის მოძრაობა თავისუფალია."},
        {id:1, text: "When you need to annotate a word or a phrase, you'll use Tags to say what the annotation is. Examples of tags are Person, Location, Object, Noun etc. You can use any tags in any language. When you need to annotate a word or a phrase, you'll use Tags to say what the annotation is. Examples of tags are Person, Location, Object, Noun etc. You can use any tags in any language."}
    ] 
    
    var next = () => {
        if(active_menu + 1 <= all_menus.length){
            active_menu++
            
        } else {
            // if(cur_sent + 1 >= sentences.length) return
            // active_menu = 1
            // cur_sent++
            // display_sent(sentences[cur_sent].text)
        }
        all_menus.forEach(menu => menu.setAttribute('class', menu.getAttribute('ind') == active_menu ? 'show' : ''))
    }
    
    var prev = () => {
        if(active_menu - 1 >= 1){
            active_menu--
            
        } else {
            // if(cur_sent - 1 < 0) return
            // cur_sent--
            // active_menu = 1
            // display_sent(sentences[cur_sent].text)
        }
        all_menus.forEach(menu => menu.setAttribute('class', menu.getAttribute('ind') == active_menu ? 'show' : ''))
    }
    
    // document.getElementById('next').addEventListener("click", next)
    // document.getElementById('prev').addEventListener("click", prev)
    
    const labels = [
        [
            {id:1, text: "Negative"},
            {id:2, text: "Mostly negative"},
            {id:3, text: "Neutral"},
            {id:2, text: "Mostly positive"},
            {id:3, text: "Positive"},
        ],
        [
            {id:1, text: "Anti west"},
            {id:2, text: "Pro-kremlian"},
            {id:3, text: "Hate speech"},
            {id:1, text: "Border"},
            {id:2, text: "Prisoners"},
            {id:3, text: "Military"},
        ],
        [
            {id:6, text: "Person"},
            {id:7, text: "Organization"},
            {id:8, text: "Event"},
            {id:9, text: "Location"},
            {id:10, text: "Hate speech target"},
            {id:6, text: "Person"},
            {id:7, text: "Organization"},
            {id:8, text: "Event"},
            {id:9, text: "Location"},
            {id:10, text: "Hate speech target"},
        ]
    ]

    // document.onkeypress = (e => {
    //     if (e.keyCode == 13) {
    //         save()
    //     }

    // })

    var cur_sent = 0
    display_sent(sentences[cur_sent].text)

    const bottomLine = document.querySelector('div.bottom-line')

    labels.forEach((labelGroup, ind) => {
        let labelGroupCont = document.createElement('div')
        labelGroupCont.setAttribute('ind', ind+1)
        bottomLine.appendChild(labelGroupCont)
        if(ind == 0) {labelGroupCont.className = 'show'}
        
        // let labelCont = document.createElement('span')
        // labelCont.innerHTML = '«'
        // labelCont.className = 'prev'
        // labelCont.onclick = prev
        // labelGroupCont.appendChild(labelCont)

        labelGroup.forEach(label => {
            let labelCont = document.createElement('span')
            labelCont.setAttribute('data-id', label.id)
            labelCont.innerHTML = label.text
            labelGroupCont.appendChild(labelCont)

            labelCont.onclick = (e) => {
                if(partOfSpeechMode){
                    save(e.target.innerText)
                } else {
                    e.target.setAttribute('style', 'background: red')
                }
            }
        })

        // labelCont = document.createElement('span')
        // labelCont.innerHTML = '»'
        // labelCont.className = 'next'
        // labelCont.onclick = next
        // labelGroupCont.appendChild(labelCont)
    })

    var active_menu = 1
    var all_menus = [...document.querySelectorAll('.bottom-line > div')]
</script>

<!-- 
    TODOS:
return words as token arrays from API
save button?
tag button color
toggle tag buttons
part of speech mode


relation sith two finger touch - how to scroll?
-->
</html>
